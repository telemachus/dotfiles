#!/usr/bin/env bash

bold='\e[1m'
underline='\e[4m'
end='\e[0m'
blue=''
green=''
let color=0
let depth=0


_show_usage()
{
    printf "%b [-h|--help|-?] [-c|--color] directory [...]\n"\
        "$bold${0##*/}$end"
}

_show_help()
{
    message="\
${bold}NAME${end}
    ${bold}btree${end} -- Bash implementation of tree

${bold}SYNOPSIS${end}
    ${bold}btree${end} [${bold}-h|--help|-?${end}] [${bold}-c|--color${end}] \
${underline}directory${end} [...]

${bold}DESCRIPTION${end}
    ${bold}btree${end} creates a recursive listing with just a hint of ASCII
    graphics for one or more requested directories.

    Unlike tree, btree will not list the current directory if no arguments
    are given. You must specify at least one directory for listing.

${bold}OPTIONS${end}
    -h|--help|-? Output this help message

    -c|--color Colorize the output in a fairly standard way

${bold}AUTHOR${end}
    Peter Aronoff (telemachus@arpinum.org)

${bold}LICENSE${end}
    The MIT License (http://www.opensource.org/licenses/mit-license.php)
"

    printf "%b" "$message"
}

_ls()
{
    if [[ -f $1 && -x $1 ]]; then
        printf "%b\n" "${green}${1##*/}${end}"
    elif [[ -f $1 ]]; then
        printf "%s\n" "${1##*/}"
    elif [[ -d $1 ]]; then
        printf "%b\n" "${blue}${1##*/}/${end}"
        thisitem="$1"
        for nextitem in "${thisitem%/}"/*; do
            _recls "$nextitem"
        done
    fi
}

_recls()
{
    extend=""
    single_extend="│   "
    for (( i=$depth; i > 0; i-- )); do
        extend=$extend$single_extend
    done

    finish="├── "

    if [[ -f $1 && -x $1 ]]; then
        printf "%s%s%b\n" "$extend" "$finish" "${green}${1##*/}${end}"
    elif [[ -f $1 ]]; then
        printf "%s%s%s\n" "$extend" "$finish" "${1##*/}"
    elif [[ -d $1 ]]; then
        printf "%s%s%b\n" "$extend" "$finish" "${blue}${1##*/}/${end}"
        thisitem="$1"
        for nextitem in "${thisitem%/}"/*; do
            (( depth++ ))
            _recls "$nextitem"
            (( depth-- ))
        done
    fi
}

while [[ $1 == -* ]]; do
    case "$1" in
        -h|--help|-\?)
            _show_help
            exit 0
        ;;
        -c|--color)
            color=1
            shift
        ;;
        -*)
            printf "Invalid option: $1\n" 1>&2
            _show_usage
            exit 1
        ;;
    esac
done

for item in "$@"
do
    unset finish extend single_extend

    if (($color == 1)); then
        blue='\e[1;34m'
        green='\e[1;32m'
    fi

    _ls "${item%/}"
    printf "\n"
done
